<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 3.2 Final//EN">
<HTML>
<HEAD><TITLE>HOW-TO for inHouse IntraNet</TITLE></HEAD>


<!-- The following are instructions to customize this web page -->
<!-- <BASE HREF="http://www.linux.org">  -->


<BODY>
<H1><CENTER>HOW-TO for inHouse IntraNet</CENTER></H1>
<H2><CENTER>Author: Sarma Seetamraju<BR>
    EMail:  (sarma@usa.net)<BR>
    Date: August 1997</CENTER>
</H2>
<H3>Place: on the Amtrack and Path Trains on the way to Downtown Manhattan.<BR>
Notepad Used: a 16-Mhz 386 SX circa 1991 Magnavox notebook running linux.<BR>
	(Just to show that if you ever complain about linux not running AS IS<BR>
	 on your computer, I am going to shove that computer up your .... )<BR>
</H4>
<H4>Reformatted as HTML for: All abnormal people who cannot stand illegible plain text.</H4>

<H2>		Important: SOCKS is a FREE package for UNIX systems.
			   I doubt its available for OTHER platforms.
			   If you wish to influence NETSCAPE to keep
			   supporting SOCKS, email me with your supporting
			   statement (saying how you are using SOCKS).
</H2>

<HR>

This document describes the procedure to set up a NETWORK (INTRANET)
at your home.  Then we shall setup up the network such that NETSCAPE Clients
can be used on ANY machine to access the internet...<P>

The network we are talking about,
<UL>
	<LI>has TWO or more computers...
	<LI>wherein, there is ONE (ONLY ONE) linux machine
	<LI>and	 the rest are Win95 or WinNT machines.
		(I doubt things will be any different for a MACintosh).

	<LI>Only the LINUX machine has PPP access to the internet.  The other
	machines MAY have modems.  I shall ignore those modems.

		<LI>if ANY of your clients are UNIX machines, you are perhaps
		better off reading the &quot;sockd&quot; package's documentation,
		since you may be needing the use of &quot;rlogin&quot;, &quot;ftp&quot; etc...
		from within the UNIX CLIENTS.  This document will not
		help you in that aspect.

	<LI>The computer network is assumed to be TCP/IP over ethernet.  No netbeui, etc...
</UL>

<STRONG><EM>The &quot;single linux&quot;  machine will be referred to as the &quot;LINUX SYSTEM&quot;. while all others are referred to as &quot;OTHER MACHINES&quot; or also as &quot;CLIENT MACHINES&quot;.  The linux machine is also referrred to as the &quot;SERVER&quot; sometimes.</EM></STRONG>

<HR>

If you do not understand the next para, then jump to the <A HREF="#NetworkingNovices">FOR NETWORK NOVICES ONLY</A> section.  Then come back here...<P>


All of the following assumes that there is an IP address assigned (using &quot;ifconfig&quot;) to the eth0 port of your LINUX server.<P>

Also, matter, this document does not restrict you to PPP only (it could be SLIP, PPTP, etc...) The IP address of the &quot;ppp0&quot; port is absolutely irrelevant.  This document assumes you have one such port, and that its UP.<P>

<HR>

<CENTER><U>WHY WE NEED SUCH AN ARRANGEMENT:</U></CENTER>
<UL>
		<LI>The linux machine is to be used to connect to the world.
		Only the linux machine has a REAL-WORLD IP address. (see below).
				(see &quot;ON-LINE services&quot; section below).
		The linux machine has a non-persistent PPP link to the world.

		<LI>The other machines in the network have IP addresses that are
		either invalid or are unknown to the world.

		<LI>You need to use the &quot;Other Machines&quot;, and NOT the linux machine
		to access the internet, VIA NETSCAPE ONLY.

		<LI>I have no need to &quot;telnet&quot; or FTP directly from the &quot;other m/c&quot;
		to the world.  If I ever need to, I telnet manually into the
		linux machine, and then into the world.
</UL>

I did NOT want to spend much on a linux m/c that didn't run an X server (much
less any X applications).  I bought a 486Dx/4 100 Mhz PCI board (since I didn't
want to be stuck with plain ISA slots), with a $20 SVGA card and a $20
NE2000 compatible card, and an extra 20$ for terminators+co-ax ('cos I didn't
know how to convert a regular Ethernet Hub connecter into a pt-2-pt connector).
<P>
And $90 worth of memory (it went all the way to $60 for 16megs) and I had a
fully functional linux system for $270.  Don't intend to burden that system
with NT or any other memory-disk-cpu hogging OSes.  Ofcourse, my client machine
is a 32-meg P100 machine with two hard disks (one of which was transplanted
as a linux machine's HD) and runs 95.<P>
	The linux system is sitting on top of a clean PizzaHut pizza box.  I
couldn't affort another $50 for a tower, since I was getting a power supply
module from one of my friends.<P>

<HR>

<STRONG><EM>The reason I chose NETSCAPE</EM></STRONG> is that I no longer use FTP manually.  Its simply, out of fashion.  Every ftp site, worth its name and every company, has a web site that lets me use the Netscape browser to access their ftp site.  I do need to telnet frequently, but go thru the trouble of going from my win95/winNT4.0 machine to the linux machine, and from there...  Secondly, I am hooked to QuickTime and all those net audio sites.  And LINUX versions of those tools, do not exist.  So, I have to run stuff from Netscape ON windows platforms.  And my LINUX machine recvs EMail using sendmail...  (remember, I have a fixed IP address.  Such fixed IP addresses are better ONLY for things like recving email.  Its no benefit for Surfing, Telnetting, etc...)<P>

Lastly, we will never have a &quot;Microsoft Explorer Browser&quot; for linux, and hence I never even considered using Explorer.  Also something tells me that its NOT going to be this easy to configure the Explorer as it was to configure the NETSCAPE on the CLIENT machines (i.e., the other machines).

<HR>

<A NAME="ProxyServer"><H3>PROXY SERVER</H3></A><P>
	I am not giving directions to installing a PROXY server.
		This is about installing a &quot;socks&quot; facility on the LINUX
machine, which NETSCAPE on the client machines can use to access the internet.

NETSCAPE (as far as I know) is the ONLY application that runs on NON-UNIX
machines and is aware of the SOCKS facility.

<HR>

<A NAME="InternetAddresses"><H3>INTERNET Addresses</H3></A><P>
  If you have a TCP/IP network, then you MUST have ATLEAST two IP addresses for the machines (one for the LINUX machine and another for the one of the Client Machines, and more IP addresses if you have more than one client machine).<P>
	Read the other HOW-TOs on how to assign IP addresses to ALL your machines on the TCP/IP network.  (ESPECIALLY IF YOU DO NOT have a REGISTERED internet domain).<P>
	I created a network 10.0.1.x out of the single LINUX machine and the single Win95 machine.  They were assigned 10.0.1.1 and 10.0.1.2 respectively.  The 10.0.1.1 is the IP address of the ETHERNET port (eth0) of the LINUX machine.  The ppp0 port has another IP (which [lucky me] has a fixed IP address).  That IP address is irrelevant to us, and also, being withheld for security reasons.<P>

I also have a fixed domain name server on the other end of the PPP link.  (University machine).<P>

The linux machine  has a modem and CRONTAB entries, that automatically dial up to the internet at fixed times daily.  I also manually connect to the internet, when I want to go surfing.<P>

If you connect to the internet via ON-LINE services, see below...

<HR>

<A NAME="OnLineServices"><H3>ON-LINE services</H3></A><P>
 If you connect to the world using ON-LINE services like AOL, Compuserve, Sprynet, Netcom etc... then  you may NOT have a fixed IP address.  That is of little relevance in getting your intrAnet hooked up to the world.  If you do not believe that, I request you to read on... and become a believer...

<HR>

<A NAME="SomeBackgroundInfo"><H3>Some Background Information</H3></A><P>
(For those who are like me and want to know what the hell is happening...).  Others may skip this section....

<OL>
<LI>  ... since you have ONLY one ethernet network, you do NOT need routing within that network.  And you perhaps have manually hardcoded the IP addresses ( 10.0.1.1, 10.0.1.2 ) of ALL your machines in /etc/hosts.  If you did that, you are smart person.  Using &quot;named&quot; for a two or three computer network at home, is like using the bulldozer instead of a spoon to eat.

<LI>  What we would ideally like, is for ALL IP packets from the client machines to go to the LINUX machine, which will then route accordingly.  Problem with this, you are exposing your computer to hackers because if the LINUX machine routes, you DO NOT have firewalling or proxy or whatever.  Here in this document, we will do firewalling unintentionally! while trying to get NETSCAPE to access internet from the client machines.<P>
	One problem with this &quot;re-routing&quot; desired from the linux machine, is that the clients MUST actually SEND ALL packets to the linux machine, no matter what the destination address.  To that end, Win95 and WinNT will ONLY allow &quot;proxy servers&quot; (Which I intend to figure out, and write another document on).

<LI>  IF you are well versed with various free utils, you may have heard
	   of &quot;term&quot; package.  It was designed simply because its easier
to configure networks being a &quot;simple&quot; user and NOT AS A ROOT/ADMIN (on both
client and server sides).  The same logic goes with NETSCAPE on the clients.
It is easier to JUST GET the netscape to access the internet and leave the
rest of the features (FTP, TELNET) unsupported.

<LI> If you think, having ONLY netscape access and NOT telnet / ftp
	   access to internet from the client machines, is a bummer, then
you are a dinosaur.  Wake Up, Mr./Ms. Rip Van Winkle.

<LI> (TECHNICAL) The &quot;named&quot; which remained unused (as mentioned above)
	   will be put to use to support NETSCAPE (so that http:/www.sex.org
will be resolved right from the client machine).

<LI>  (TECHNICAL) You will have to REBUILD your LINUX kernel to disable
	    IP forwarding.  I intend to rebuild my kernel with forwarding
ENABLED and see if the socks package still works (I am betting it will).  If
it does, then you will find a newer version of this document.
	(What this means, is that, you can use the kernel installed by your
favorite LINUX installation package).

<LI> You will need ROOT access on the linux machine :-)
	   You will need to download the socks package and COMPILE it.
	   It will NOT compile 'cos the MAKE file is bad.

<LI> (TECHNICAL) be prepared to edit the socks.c file, to comment out
	   ONLY two lines which place an entry in your syslog file (/var/adm)
for every data transfer via socks.  For eg: a single page on WWW.CNN.COM
will have 10 pictures atleast and 5 separate text objects.  For each of them
you will find an entry in syslog (that it was transferred!).  My syslog keeps
filling up.  I do NOT like that.  Maybe you might not mind.

<LI> This sockd package supports CLIENT machines ONLY.  All applications
	on the LINUX machine DO NOT need the sockd or any other package
	to access the internet, since this LINUX machine connects to internet
	directly using PPP.
</OL>

<HR>

<A NAME="PreparingYourLinuxMachine"><H3>PREPARING YOUR LINUX MACHINE</H3></A><P>
Read the NET-HOW-TO in <TT>/usr/doc/faq/howto</TT>   on your linux machine (if its slakware), or go to the <TT>www.linux.org</TT> and read the same NET-HOW-TO there...<P>

In that you will find how to down load the socks package and compile it.
You NEED TO READ the instructions there to setup the in-house network.
But you are welcome to read this :-) .<P>

That document spends a lot of time, explaining how to configure UNIX clients.  Especially for &quot;rlogin&quot; &quot;telnet&quot; &quot;ftp&quot; etc...  If you do not have UNIX clients, then after compiling the SOCKS package, start reading this document again, for using the socks package rather than the readme file in that package.<P>

I placed the tar file in <TT>/usr/local/ProxyServer</TT> and untarred it, creating a &quot;sockd4.2b&quot; subdirectory within which there is a &quot;Makefile&quot;.  As mentioned in the howto document, I had to struggle to successfully do a
make on the MAKEFILE.<P>

<HR>
	<CENTER>For your convenience, the MAKEFILE is included at <A HREF="#SockdMakefile">end</A>...<P>
		Hopefully, you will have change line # 9 of my copy of the Makefile, only.</CENTER>
<HR>

Then I moved the sockd directory contents into its parent and changed the
line # 9 and did a make again -- successfully.  So I guess I &quot;fixed&quot; the MAKEFILE.

<HR>

<A NAME="SettingUpSockd"><H3>Setting UP the sockd daemon</H3></A><P>
You will find an executable called &quot;sockd&quot; in the sockd subdirectory.<P>

<PRE>
Once you are done compiling, <EM>COPY the following files to</EM> <TT>/usr/local/etc</TT>
(They SHOULD be in the same dir as the sockd directory)
	sockd			(The executable a.k.a daemon)
	sockd.conf		(configuration file)
	sockd.route		(configuration file)
	socks.conf		(configuration file)

# ### make a link called &quot;socks&quot; which points to &quot;sockd&quot; within the same dir.
# cd /usr/local/etc
# ln -s sockd socks
</PRE>

Then edit those three configuration files so that they are similar to the ones given below (these are my settings for a two computer network, made up of a LINUX &quot;server&quot; and a Win95/WinNT client machine).

<HR>

<A NAME="MySockdConfFile"><H3>My sockd.conf file</H3></A>
<PRE>
<NOBR>
permit	10.0.1.2    0.0.0.0
deny	0.0.0.0 0.0.0.0 : /usr/ucb/finger @%A | /usr/ucb/mail -s 'SOCKD: rejected -- from %u@%A to host %Z (service %S)' root
#BAD_ID: /usr/ucb/finger @%A | /usr/ucb/mail -s '%U pretends to be %u on host %A' root@%A root
#NO_IDENTD: /usr/ucb/mail -s 'Please run identd on %A' %u@%A root@%A
#[EOF]
</NOBR>
</PRE>

<STRONG>NOTE</STRONG>:   10.0.1.2 is my Win95/WinNT client machine's IP address.  This sockd.conf file MUST be on your LINUX server (in my case that the ethernet port of the LINUX server has an IP address = 10.0.1.1)<P>

<STRONG>NOTE</STRONG>:	This sockd program is for CLIENT machines ONLY.  All applications on the LINUX machine DO NOT need the sockd or any other package to access the internet, since this LINUX machine connects to internet directly using PPP.<P>

<HR>

<A NAME="MySocdRouteFile"><H3>My sockd.route file</H3></A>
<PRE>
#! NoShell 
10.0.1.1	10.0.1.0	255.255.255.0
#[EOF]
</PRE>

<STRONG>NOTE</STRONG>: The first IP address is the address of the LINUX machine's eth0 PORT.  The second IP number is NOT an IP address -- Its the NETWORK address (basically, convert the last of the FOUR numbers of the IP address into a ZERO).

<HR>

<A NAME="SocksConfFile"><H3>My socks.conf file</H3></A>

<PRE>
direct	127.0.0.1	255.255.255.255
direct	10.0.1.1	255.255.255.255
direct	10.0.1.2	255.255.255.255
sockd	@=199.99.99.99	10.0.1.1 0.0.0.0
</PRE>

<HR>
<HR>
<HR>

<A NAME="ConfigureLinuxMachine"><H3>Now to configure the LINUX machine</H3></A>

<UL>
<LI><STRONG>Step # 1:</STRONG>  Check to see if &quot;named&quot; is already running in your system.  If it is -- then, you are on your own.  Unless you know the concepts of DNS very well, you may not be able to adapt the contents of this document to suit your needs.
<LI><STRONG>Step # 2:</STRONG>  Copy the &quot;named.boot&quot; file given below into your machine.
<LI><STRONG>Step # 3</STRONG>:  copy the &quot;root.cache&quot; file given below into your machine (follow instructions that come with it).
</UL>

<HR>

<A NAME="hostconfFile"><H3>/etc/host.conf file</H3></A>

All programs that run on the LINUX machine WILL (you cannot prevent that) use the resolver libraries -- which depend on the file /etc/host.conf<P>

You must make sure that NONE of these programs ever access the &quot;named&quot; daemon on THAT VERY linux machine.  To do that we shall specify to the resolver routines (i.e., routines which convert www.cnn.com into the numerical ip address) that those resolver routines MUST either check the /etc/hosts file and then check the DNS servers mentioned in /etc/resolv.conf<P>

How do we do that? Simply, make sure the /etc/host.conf file is :-<P>
<PRE>
		order hosts, bind
		multi on
</PRE>
If there is anything else, remove it, unless you know a lot about DNS and &quot;named&quot;.<P>

The reason I insist on preventing the LINUX machine's applications from accessing its own &quot;named&quot; server, is because it makes no sense.  And from my experience, such a &quot;unnecessaries&quot; may look technically safe and harmless but will cause enough grief sooner or later...<P>

The linux machine is obviously doing just great accessing the internet via the PPP (or whatever link) link.  We are installing &quot;sockd&quot; package and the &quot;named&quot; daemon for the client machines.  Let's not disturb the LINUX system.

<HR>

You DO NOT NEED to change the <TT>&quot;/etc/gateways&quot;   or   &quot;/etc/hosts&quot;  file or the &quot;hosts.allow&quot;   or  the &quot;hosts.deny&quot;</TT> file in order to get your socks working.<P>

Do not change any file unless someone suggests a change to that file...<P>

I will also assume that you have setup &quot;resolv.conf&quot; properly, to enable your LINUX server to access the internet and the DNS (on the &quot;other end&quot; of the PPP connection).  My sample resolv.conf file is available as a sample at the very end.<P>

<PRE><STRONG>
		***********************************************
				WARNING
		***********************************************
		For your own good, I suggest that you setup your
		machine through the linux installation programs
		(i.e., while installing linux on your computer.)
		************************************************
</STRONG></PRE>

<HR>

<A NAME="NamedBootFile"><H3>My named.boot file</H3></A>
<PRE>
	;    boot file for name server
	forwarders 128.112.129.111
	directory /etc
	cache      .       root.cache
	primary    1.0.10.in-addr.arpa   named_DNS_for_inTi_xwk
					 ^^^^^^^^^^^^^^^^^^^^^^
</PRE>

NOTE: line # 2, contains the IP address of the DNS server in the network to which your LINUX machine connects to using PPP(or whatever).

<H3>*** How to determine this IP Address ****</H3>

SIMPLE !   on a command prompt type in the command &quot;nslookup&quot;.  The response you see will CONTAIN such an IP address.  (After noting the DNS' IP address, exist &quot;nslookup&quot; using &LT;CTL-D&GT;.<P>

<STRONG>NOTE</STRONG>:  The LAST line contains the <STRONG>name of a file</STRONG> called &quot;named_DNS_for_inTi_xwk' which MUST be in the &quot;/etc&quot; directory.  The contents of this file, is given below (you are free to give it a better name :-)   )

<HR>

<A NAME="namedDNSforIntiFile"><H3>My &quot;named_DNS_for_inTi_xwk&quot; file</H3></A>
<PRE>
@		IN	SOA     10.0.1.0 hostmaster.10.0.1.0 (
				1       ; Serial
				28800   ; Refresh
				7200    ; Retry
				604800  ; Expire
				86400)  ; Minimum TTL
			NS	10.0.1.1
1			PTR	MyLinuxMachine
</PRE>

<STRONG>NOTE</STRONG>: The last line (starts with a 1) contains the name &quot;MyLinuxMachine&quot;.  replace it with the name in /etc/HOSTNAME.

<STRONG>NOTE</STRONG>: Again , as you have been doing so far, replace &quot;10.0.1.1&quot; with that of your LINUX machine eth0 port's address, and replace &quot;10.0.1.0&quot; with that of the network address of that port.

<STRONG>NOTE</STRONG>: I really do not understand every character of the above file.  You will be better off statisfying your curiousity by studying the documentation for the NAMED daemon.

<HR>

<A NAME="RootCacheFile"><H3>My root.cache file</H3></A><P>
<EM>
To get this file read the NET-HOW-TO documentation and the documentation that comes with the socks package.<P>
Those instructions are VERY simple...<P>
All I did was to run a command mentioned there, and redirected it into a file and called it <TT>&quot;/etc/root.cache&quot;</TT><P>
</EM>

<PRE>
; <<>> DiG 2.1 <<>> ns 
;; res options: init recurs defnam dnsrch
;; got answer:
;; ->>HEADER<<- opcode: QUERY, status: NOERROR, id: 6
;; flags: qr rd ra; Ques: 1, Ans: 9, Auth: 0, Addit: 9
;; QUESTIONS:
;;	., type = NS, class = IN

;; ANSWERS:
.	137030	NS	C.ROOT-SERVERS.NET.
.	137030	NS	D.ROOT-SERVERS.NET.
.	137030	NS	E.ROOT-SERVERS.NET.
.	137030	NS	I.ROOT-SERVERS.NET.
.	137030	NS	F.ROOT-SERVERS.NET.
.	137030	NS	G.ROOT-SERVERS.NET.
.	137030	NS	A.ROOT-SERVERS.NET.
.	137030	NS	H.ROOT-SERVERS.NET.
.	137030	NS	B.ROOT-SERVERS.NET.

;; ADDITIONAL RECORDS:
C.ROOT-SERVERS.NET.	410161	A	192.33.4.12
D.ROOT-SERVERS.NET.	410161	A	128.8.10.90
E.ROOT-SERVERS.NET.	410161	A	192.203.230.10
I.ROOT-SERVERS.NET.	167767	A	192.36.148.17
F.ROOT-SERVERS.NET.	410161	A	192.5.5.241
G.ROOT-SERVERS.NET.	410161	A	192.112.36.4
A.ROOT-SERVERS.NET.	410161	A	198.41.0.4
B.ROOT-SERVERS.NET.	410161	A	128.9.0.107
H.ROOT-SERVERS.NET.	410161	A	128.63.2.53

;; Total query time: 334 msec
;; FROM: svathyam to SERVER: default -- 128.112.129.111
;; WHEN: Sat Sep 28 21:38:04 1996
;; MSG SIZE  sent: 17  rcvd: 312
</PRE>

<HR>

<A NAME="EtcServicesFile"><H3>Add this to /etc/services</H3></A><P>

(add the single line starting with &quot;socks&quot;...)
<PRE>
# services	This file describes the various services that are
#		available from the TCP/IP subsystem.  It should be
#		consulted instead of using the numbers in the ARPA
#		include files, or, worse, just guessing them.
# Version:	@(#)/etc/services	3.02	02/21/93
# Author:	Fred N. van Kempen, <waltje@uwalt.nl.mugnet.org>

... &LT;lines delete&GT;

socks		1080/tcp			# sarma: Sep.15.96: Got this from the ~sockd/include/socks.h file.

... &LT;lines delete&GT;

# End of services.
</PRE>


<STRONG>NOTE</STRONG>: This line is read ONLY by inetd daemon I think.  This tells the inetd to invoke the &quot;socks&quot; program for all tcp connections to the port # 1080.

<HR>

<A NAME="INETD.CONFfile"><H3>Add this to your /etc/inetd.conf file</H3></A>

<PRE>
	# I am just following instructions from ~sockd/doc/sockd.1 man pages...
	socks   stream  tcp     nowait  root    /usr/local/etc/socks
</PRE>

<UL>
<LI>NOTE: Make sure /usr/local/etc is in the SYSTEMS's default PATH.
<LI>NOTE: For more instructions, read the SOCKD package's instruction file.  In that this very same line is mentioned, and also you will get to know what it means...
<LI>NOTE: As the filename indicates, this file tells the &quot;inetd&quot; daemon where it can find the &quot;socks&quot; program, and what arguments to pass it (always)
	etc...
</UL>

<HR>
<HR>
<HR>

<A NAME="LetsGetStarted"><H3>LET'S GET STARTED !</H3></A>

Now reboot your system (if you know how, you may instead send HUP to the appropriate daemons).  Your LINUX server is now set.<P>

do a <TT>&quot;tail -f /var/adm/messages&quot;  and a &quot;tail -f /var/adm/syslog&quot;</TT> simultaneously and attempt to connect using NETSCAPE from your CLIENT machines.<P>

	Now let's configure the client machine's Netscape...

<HR>

<A NAME="ConfiguringNetscapeClient"><H3><CENTER>Configuring NETSCAPE 3.0 Client</CENTER></H3></A>

<CENTER>This is to be DONE on the client machines ONLY<BR>
DO NOT bother doing this on the LINUX server.</CENTER><P>

<UL>
<LI>Pull down the menu called &quot;options&quot; in Netscape.
<LI>Choose &quot;Network Preferences&quot;.
<LI>You MUST see a dialog box (new window) with &quot;TABS&quot; (layers)...
<LI>One of the &quot;tabs&quot; will be labelled &quot;PROXIES&quot;
<LI>Click on that layer/tab.
<LI>You will see a radio button labelled &quot;manual proxy configuration&quot; with a button beside.
<LI>CLick on that button to open up another dialog box.
<LI>The second last set of entry slots in that new window will show you...
</UL>

<PRE>
	--------- --------------------------              --------
	| socks | |                        |		  | 1080 |
	--------- --------------------------              --------
</PRE>

This shows that netscape is already aware of socks.  All you have to do is to tell NETSCAPE where the socks daemon is running.<P>

Type in the <STRONG><TT>eth0 port IP address</TT></STRONG> of the linux server in the <U>middle box</U> shown above...<P>

Save this setting and get going... !!<P>

<HR>
<HR>
<HR>

<A NAME="NetworkingNovices"><H3>For Networking NOVICES</H3></A>

	If you have already used your Win95 or WinNT machines to connect to the internet via PPP, this documents is of absolutely NO help to you.  Anyways, why bother using linux to connect to the internet when you can do so via the client machine's built-in PPP?<P>

	If you haven't been able to connect to the internet via the LINUX server, then stop reading this document and read the other HOW-TO documents to setup your LINUX machine to access the internet via the PPP link.<P>

I hope you know the concept of IP addresses.  In short IP addresses have &quot;mnemonics&quot; formats (like www.cnn.com) as well as numeric versions like &quot;198.20.186.4&quot;.  If you type the former &quot;www.cnn.com&quot; someone must HELP your computer convert that name into the numerical format.<P>

	Why the numerical format?  'cos, that numerical format encodes a very efficient system of telling each computer HOW to send out communication capsules to OTHER computers THAT IT WANTS TO communicate to.<P>

	So, if you type in &quot;www.cnn.com&quot; on your NETSCAPE browser, then a UNIX computer called a &quot;DNS server&quot; will convert that name into a number for your computer.  Then your computer will use that numerical format of the IP address to actually CONNECT to www.cnn.com and show you their latest news.<P>

So, the gist being that : to use the internet you need a DNS server.  This document includes instructions on setting up your computer to HOOK up to your NEIGHBORHOOD DNS server.<P>

Your LINUX machine MUST have ALL of the following :-
<OL>
<LI>	A modem, through which you can connect to INTERNET *** DIRECTLY ***
<LI>	An ethernet card, to which you have the ethernet cable hooked up (the other ends of which you have your client machines hooked up to...)
<LI>	A Working PPP connection.
<LI>	A Valid DNS server information (use nslookup --- if that program retuns invalid values, stop reading this document.  You WILL NOT be able to proceed...)
<LI>	Netscape 2.0 or later on your client machines.)
</OL>

The &quot;modem&quot; is technically referred to as the &quot;ppp0 port&quot; as far as this document is concerned.  By &quot;port&quot; I mean something similar to a &quot;Sea-Port&quot;.  This modem or PPP port enables you to &quot;explore the world&quot; (go on a &quot;vacation&quot; from daily chores) :-)<P>

The &quot;ethernet card&quot; is your &quot;eth0&quot; port.  That ethernet &quot;port&quot; lets you explore the ethernet network to which its connected.<P>

Since your client machines are connected via the ethernet cable to the LINUX machine, anything that your client machine communicates to the LINUX machine will ONLY REACH the linux machine VIA the &quot;eth0&quot; port.   ANything that the outside world sends to your LINUX machine will ONLY REACH via the &quot;ppp0 port&quot;.  So, its very important that these two ports be given &quot;DIFFERENT ADDRESSES&quot;.<P>

To make things easier for you, if you ALREADY successfully connected to the world using PPP, then, you have UNKNOWINGLY (or knowingly) assigned an IP numerical address to your linux machine's PPP port.<P>

<HR>

<A NAME="SockdMakefile"><H3>The MAKEFILE for sockd compilation</H3><A>

<PRE>
	SHELL=/bin/bash
	#SOCKS=-DSOCKS
	# or
	SOCKS=-Dconnect=Rconnect -Dgetsockname=Rgetsockname -Dlisten=Rlisten -Daccept=Raccept -Drcmd=Rrcmd -Dbind=Rbind -Dselect=Rselect
	CFLAGS=&quot;$(SOCKS)&quot;
	
	# If your system doesn't have PWD defined, define it here:
	PWD=&quot;/usr/local/ProxyServer/socks42b&quot;
	# It should be this current directory.
	
	# If your system has getcwd() but no getwd(), uncomment the next line:
	#GETCWD=-DGETCWD
	
	# Define FASCIST if you want ftp (rftp) to log names of all files transferred
	#FASCIST=-DFASCIST
	
	# Define RCMD and SUPPORT_RCMD if you want to support Rrcmd, which is required
	# for SOCKSified rlogin, rsh, and rcp.
	RCMD=Rrcmd.o
	SUPPORT_RCMD=-DSUPPORT_RCMD
	
	# Define FOR_PS if your system is not SYSV and you want to have the
	# command 'ps' show some details of sockd's activity.
	FOR_PS=-DFOR_PS
	
	# Define SHORTENED_RBIND to make Rbind() take exactly the same
	# argument list as the regular bind(), i.e., without the additional
	# 'remhost' argument.
	SHORTENED_RBIND=-DSHORTENED_RBIND
	
	# optimization flag for cc
	#OPTIMIZE=-g
	OPTIMIZE=-O6 -fomit-frame-pointer -pipe -m486
	# Be careful with the OPTIMIZE flag. SunPro's SC2.0.1, for example, is
	# knwon to produce incorrect code when -O is used.
	
	# Directory into which to install the man pages
	MAN_DEST_DIR = /usr/local/man
	
	# Directory into which the SOCKS server should be installed
	SERVER_BIN_DIR = /usr/local/ProxyServer
	## This was defalted to /usr/local/etc 
	
	# Directory into the client programs should be installed
	CLIENTS_BIN_DIR = /usr/local/ProxyServer
	## This was defaulted to /usr/local/bin

	# LINUX should use
	CC=gcc
	RANLIB=ranlib
	RESOLV_LIB=
	#OTHER_CFLAGS=-traditional -DLINUX  $(GETCWD) $(FASCIST) $(SHORTENED_RBIND) -DCOMPAT 
	OTHER_CFLAGS=-DLINUX  $(GETCWD) $(FASCIST) $(SHORTENED_RBIND) -DCOMPAT 
	OS=linux
	INSTALL=install
	GETPASS=getpass.o

	# Remember to include -Dindex=strchr -Drindex=strrchr in OTHER_CFLAGS if
	# you don't have index() and rindex() (Sys-V camp)
	
	# <<<----------------
	
	# The Internet Whois server; used to be nic.ddn.mil.
	WHOIS_SERVER= WHOIS_SERVER=-DWHOIS_SERVER\'=\&quot;rs.internic.net\&quot;\'
	
	SOCKS_LIB=$(PWD)/lib/libsocks.a
	IDENT_LIB=$(PWD)/libident/libident.a
	
	all: LIB LIBIDENT server clients
	
	server: LIB LIBIDENT
		(cd sockd; $(MAKE) CC=&quot;$(CC)&quot; RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; \
			OPTIMIZE=&quot;$(OPTIMIZE)&quot; \
			SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; SUPPORT_RCMD=&quot;$(SUPPORT_RCMD)&quot; \
			IDENT_LIB=&quot;$(IDENT_LIB)&quot; \
			OTHER_CFLAGS=&quot;$(OTHER_CFLAGS) $(FOR_PS)&quot;)
		
	clients: RFINGER RFTP RTELNET
	
	LIB:
		(cd lib; $(MAKE) CC=&quot;$(CC)&quot; GETPASS=&quot;$(GETPASS)&quot; \
			OPTIMIZE=&quot;$(OPTIMIZE)&quot; \
			RCMD=&quot;$(RCMD)&quot; SUPPORT_RCMD=&quot;$(SUPPORT_RCMD)&quot; \
			OTHER_CFLAGS=&quot;$(OTHER_CFLAGS) &quot; RANLIB=&quot;$(RANLIB)&quot;)
	
	LIBIDENT:
		(cd libident; $(MAKE) CC=&quot;$(CC)&quot; OTHER_CFLAGS=&quot;$(OTHER_CFLAGS)&quot; \
			OPTIMIZE=&quot;$(OPTIMIZE)&quot; RANLIB=&quot;$(RANLIB)&quot;)
	
	RFINGER: LIB
	# This also build rwhois
		(cd rfinger; $(MAKE) CC=&quot;$(CC)&quot; $(WHOIS_SERVER) \
			OPTIMIZE=&quot;$(OPTIMIZE)&quot; SOCKS=&quot;$(SOCKS)&quot; \
			RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; \
			OTHER_CFLAGS=&quot;$(OTHER_CFLAGS) &quot;)
	
	RTELNET: LIB
		(cd rtelnet; $(MAKE) CC=&quot;$(CC)&quot; OS=&quot;$(OS)&quot; SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; \
			OPTIMIZE=&quot;$(OPTIMIZE)&quot; SOCKS=&quot;$(SOCKS)&quot; \
			RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; OTHER_CFLAGS=&quot;$(OTHER_CFLAGS)&quot;)
	
	RFTP: LIB
		(cd rftp; $(MAKE) CC=&quot;$(CC)&quot; SOCKS_LIB=&quot;$(SOCKS_LIB)&quot; \
			OPTIMIZE=&quot;$(OPTIMIZE)&quot; SOCKS=&quot;$(SOCKS)&quot; \
			RESOLV_LIB=&quot;$(RESOLV_LIB)&quot; OTHER_CFLAGS=&quot;$(OTHER_CFLAGS)&quot;)
	
	install.server:
		(cd sockd; $(MAKE) INSTALL=&quot;$(INSTALL)&quot; MAN_DEST_DIR=&quot;$(MAN_DEST_DIR)&quot; \
			SERVER_BIN_DIR=&quot;$(SERVER_BIN_DIR)&quot; install install.man)
	
	install.clients: install.man
		for i in rfinger rftp rtelnet; do \
			(cd $$i ; $(MAKE) INSTALL=&quot;$(INSTALL)&quot; \
				CLIENTS_BIN_DIR=&quot;$(CLIENTS_BIN_DIR)&quot; \
				install) done
	install.man:
		(cd doc; $(MAKE) INSTALL=&quot;$(INSTALL)&quot; MAN_DEST_DIR=&quot;$(MAN_DEST_DIR)&quot; \
			install)
	
	clean:
		for i in lib libident sockd rfinger rftp rtelnet ; do \
			( cd $$i ; $(MAKE) clean) done
</PRE>

	
<HR>

<A NAME="ppponScript"><H3>The ppp-on script</H3></A>

NOTE: This script is being provided as a sample.  Having this sample is not a guarantee that you will have an internet connection.

<PRE>
	#!/bin/csh
	#
	#	ppp-on
	#
	#	Set up a PPP link
	
	set LOCKDIR=/var/spool/uucp
	set DEVICE=cua3
	
	set OUR_IP_ADDR=128.000.111.222
	
	if ( -f $LOCKDIR/LCK..$DEVICE ) then
	    echo 'PPP device is locked'
	    exit 1
	endif
	
	route del default
	# Just in case the Ethernetwork (In-House ethernet network) is up....
	#	if its NOT, then the above command is harmless...
	route ## To show that the above was successful...
	
	/usr/lib/ppp/fix-cua $DEVICE
	
	    unalias pushd
	    unalias popd
	    pushd /usr/lib/ppp
	    # stty 19200 -tostop
	
	    # The original code has been commented out below...
	    # if chat -l LCK..$DEVICE ABORT &quot;NO CARRIER&quot; ABORT BUSY &quot;&quot; ATZ OK ATs50=255s111=0DT$PHONE CONNECT &quot;&quot; ogin: $USER ssword: \\q$PASSWORD
	    echo $cwd
	    ls -l ./comserv.dip
	    dip ./comserv.dip       ## I removed the -v (DEBUG&amp;VERBOSE) option to 'dip'.
	    set dip_status=$status
	    # echo the return value of dip is $dip_status
	
	    if $dip_status == '0' then
	        # Now please wait for 10 seconds, while the link is being auto-verified by dip.
	        echo 'About to fork-off pppd (after a delay of 10 secs)...'
		date
	        echo 'If you see any error msgs below, then we are having SERIOUS problems...'
	        sleep 10
		pppd -detach crtscts defaultroute domain remote.princeton.edu mru 1005 mtu 1005 $OUR_IP_ADDR{}: /dev/$DEVICE 38400 &amp;
	        ###### we dont need this for the previous line...    < /dev/$DEVICE > /dev/$DEVICE ) &amp;
	        #    The pppd deamon is FORKED OFF.  See the &quot;&amp;&quot; at the END of above line...
	        # By using &quot;locl&quot; option, I am requesting that /var/spool/uucp be the dir
	        #    in which the LOCKS are created...
	        echo 'Now wait another 10 seconds, before I auto-verify internet connection.'
		sleep 10
		cat ~root/@utils/.line
	        ping -v -c 5 genius.eng.wayne.edu
		cat ~root/@utils/.line
		traceroute physics.iisc.ernet.in >&amp;! /tmp/$$
						cat  /tmp/$$
						\rm -f /tmp/$$
		cat ~root/@utils/.line
		exit 0
	    else
		echo 'PPP setup failed'
		exit 1
	    endif
	    popd
	# [EoF]
</PRE>

<HR>

<A NAME="ComservDipScript"><H3>The comserv.dip script to dial up PPP.</H3><A><P>

NOTE: This script is being provided as a sample.  Having this sample is not a guarantee that you will have an internet connection.  This script is called from the PPP-ON script given above...

<PRE>
	#******************************** comserv.dip ********************************
	#
	# Connection script for SLIP to ........
	# STATUS code for &quot;dip&quot; when it executes this script are:
	#  0 - all ok.
	#  1 - basic failures, in initializing the modem.
	#  2 - Failed in the crucial &quot;dial&quot; command.
	#  3 - Though DIAL command was successful, this script couldnt recognize
	#      the VERY FIRST responses from the other modem. (i.e., Training occured
	#      but, after that nothing happened that was intelligible to this script.
	#  4 - Modems could nicely link up.  But remote server HAS CHANGED syntax.
	#      i.e., the strings output by the server, are assumed to arrive in a
	#      PARTICULAR sequence.  If server s/w has changed, then we have this
	#      problem.  SOLUTION!!!! Manually connect and note all the strings &amp;
	#      all the sequence of interactions...  Then reprogram the script below.
	# 10 - though dialing and connecting (modem-wise) is successful, ppp failed.
	############################################################################
	main:
	redial:
	  # Set the desired serial port and speed.
	  port cua3
	  speed 38400
	  # term
	  get $mtu 1005
	  # Reset the modem and terminal line.
	  reset
	  # Without doing the above reset, nothing below will work!
	  # Initialize the modem and dial comserv.
	  # send ATQ0V1E1X4L1S0 0 \r
	  # wait OK 5
	  send ATZ\r
	  wait OK 5
	  if $errlvl != 0 goto error
	  # send ATTQ0V1E1X4S0=0&amp;C1\r
	  # wait OK 5
	  # if $errlvl != 0 goto error
	  ## For Dial Tone use :- send AT&amp;D2\r
	  send AT&amp;DP\r
	  wait OK 5
	  if $errlvl != 0 goto error
	  # send ATS10=1\r
	  # wait OK 5
	  # if $errlvl != 0 goto error
	  print if the line is busy, the dial command will realize that after 30 secs ONLY.
	  dial 258-0000   30
	  print Return value of DIAL is $errlvl
	  if $errlvl == 1 goto Continue1
	  if $errlvl == 3 goto busy
	  print unknown error with DIAL command in &quot;dip&quot; script.
	  quit 2 # unknown error with crucial DIAL command...
	busy:
	  print telephone number is busy... Continue (1) or terminate (2)?
	  get $input ask
	  if $input == 1 goto redial
	  print You have requested to cancel PPP.  Quitting...
	  quit 10 # terminated...
	Continue1:
	  # wait V32 30
	  # wait CONNECT 10
	  # if $errlvl != 0 print Couldn't detect a CONNECT
	  # if $errlvl != 0 goto connect_fail
	  # print CONNECT was detected...
	  # We are connected.  Login to the system.
	login:
	  sleep 3
	  # send \r\r
	  wait Username: 20
	  if $errlvl != 0 goto error2
	  send USERID\r
	  wait Password: 5
	  if $errlvl != 0 goto error2
	  send __Password+_::\r\r
	  wait comserv> 15
	  # print Reached Comserv prompt...
	  if $errlvl != 0 goto error2
	slipon:
	  send ppp\r
	  wait PPP_STARTED 25
	  if $errlvl != 0 goto error2
	  print CONNECTION completed...
	  mode ppp
	  exit 0
	error:
	  print Total failure to interact with MODEM!!!
	  quit 1 # basic failure in working with modem, etc...
	connect_fail:
	  print Couldnt detect a &quot;CONNECT 14400&quot; kind of string after dial in...
	  quit 3
	error2:
	  print Modems could nicely link up.  But remote server HAS CHANGED syntax/ interaction sequence...
	  quit 4 # basic failure in working with modem, etc...
	#=================================== EOF ===================================
</PRE>

</BODY>
</HTML>
